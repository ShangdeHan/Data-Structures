This is the group project with team members: Shangde Han, Tao Li
changes:
	We debugged it and found that in Search method we did not return 
null if we cannot find this node. 
	Insert method rotation parts are too complex to see where has 
problems. So, we decided to move rotation parts to help function and call it
in insert method. Original submission has some small problems when we link 
new node with its parents and we fixed it. Then, all testcases can run normally.
The folowing is information about this assignment:


COMPUTER SCIENCE 311SPRING 2020PROGRAMMING ASSIGNMENT 1INTERVAL TREAPSDUE: 11:59 P.M., APRIL 5Note.This assignment is adapted from Chapter 14 of CLRS1. The chief differencewith respect to CLRS is that here we use treaps instead of red-black trees.1. OverviewAclosed intervalis an ordered pair of real numbers[a,b], witha≤b. The interval[a,b]represents the set{x∈R:a≤x≤b}, whereRdenotes the set of all real numbers.Aninterval databaseis a data structure that maintains a dynamic set of elements, with eachelementxcontaining an intervalx.interv. An interval database supports the following operations:intervalInsert(x):adds the elementx, whoseintervfield references an interval, to thedatabase.intervalDelete(x):removes the elementxfrom the database.intervalSearch(i):returns a reference to an elementxin the interval database such thatx.intervoverlaps intervali, ornullif no such element is in the set.Intervals are convenient for representing events that each occupy a continuous period of time.We might, for example, wish to query a database of time intervals to find out what events occurredduring a given interval. The goal of this assignment is to design a data structure based on treapsthat efficiently maintains an interval database.Teamwork.For this programming assignment, you can work in teams of two people. It is yourresponsibility to find a teammate, if you wish to have one.This project is worth 100 points, plus at most 15 extra credit points.2. The Data StructureWe represent an interval[a,b]as an objecti, with attributesi.low=a(the low endpoint) andi.high=b(the high endpoint). We say that intervalsiandi′overlapifi∩i′,∅, that is, ifi.low≤i′.highandi′.low≤i.high. The following fact, illustrated in Figure 1, is known as theinterval trichotomy.Fact.Any two intervalsiandi′satisfy exactly one of the following three properties:(a)iandi′overlap,(b)iis to the left ofi′(i.e.,i.high<i′.low),(c)iis to the right ofi′(i.e.,i′.high<i.low).1T. H. Cormen, C. E. Leiserson, R. L. Rivest and C. Stein,Introduction to Algorithms(3rd edition), MIT Press,2009.Originally posted March 3. 1st revision, March 4; changes in blue. 2nd revision, March 16; significant changes inpurple. 3rd revision, March 20; modified due date in green. 4th revision, March 29; replacedmaxbyimaxin Figure 2.1
14.3  Interval trees349iii i(a)i(b)i(c)i′i′i′i′i′i′Figure 14.3The interval trichotomy for two closed intervalsiandi0.(a)Ifiandi0overlap, thereare four situations; in each,i:low!i0:highandi0:low!i:high.(b)The intervals do not overlap,andi:high<i0:low.(c)The intervals do not overlap, andi0:high<i:low.INTERVAL-INSERT.T; x/adds the elementx,whoseintattribute is assumed tocontain an interval, to the interval treeT.INTERVAL-DELETE.T; x/removes the elementxfrom the interval treeT.INTERVAL-SEARCH.T; i /returns a pointer to an elementxin the interval treeTsuch thatx:intoverlaps intervali,orapointertothesentinelT:nilif no suchelement is in the set.Figure 14.4 shows how an interval tree represents a set of intervals. We shall trackthe four-step method from Section 14.2 as we review the design of an interval treeand the operations that run on it.Step 1: Underlying data structureWe choose a red-black tree in which each nodexcontains an intervalx:intand thekey ofxis the low endpoint,x:int:low,oftheinterval.Thus,aninordertreewalkof the data structure lists the intervals in sorted order by low endpoint.Step 2: Additional informationIn addition to the intervals themselves, each nodexcontains a valuex:max,whichis the maximum value of any interval endpoint stored in the subtree rooted atx.Step 3: Maintaining the informationWe must verify that insertion and deletion takeO.lgn/time on an interval treeofnnodes. We can determinex:maxgiven intervalx:intand themaxvalues ofnodex’s children:Figure 1.The interval trichotomy for two closed intervalsiandi′. (a) Ifiandi′overlap, there are four situations; in each,i.low≤i′.highandi′.low≤i.high.(b)The intervals do not overlap, andi.high<i′.low. (c) The intervals do not overlap,andi′.high<i.low. (Source: CLRS.)1intervalSearch(i):2x=T.root3whilex,nullandidoes not overlapx.intervdo4ifx.left,nullandx.left.imax≥i.lowthen5x=x.left6else7x=x.right8returnxAlgorithm 1:Searching for an interval in the database that overlaps intervali.In this project, you will represent an interval database using a treapT, called anintervaltreap, in which each nodexcontains an intervalx.intervand the key ofxis the low endpoint,x.interv.low, of the interval. Thus, an inorder tree walk ofTlists the intervals in sorted order bylow endpoint. In addition to the intervals themselves, each nodexofTcontains a valuex.imax,which is the maximum value of any interval endpoint stored in the subtree rooted atx. See Figure2. We use theimaxfield to implementintervalSearch, as shown in Algorithm 1.The search for an interval that overlapsistarts withxat the root of the tree and proceedsdownward. It terminates when either it finds an overlapping interval orx==null. The key ideabehindintervalSearchis that at any nodex, ifx.intervdoes not overlapi, the search alwaysproceeds in a safe direction:•Supposex.left,nullandx.left.imax≥i.low. Then, if there exists an interval thatoverlapsi, the left subtree must contain such an interval.2Thus, we proceed to the left.•Supposex.left==nullorx.left.imax<i.low. Then, no interval inx’s left subtreeoverlapsi. Thus, we proceed to the right.Thus, the search will find an overlapping interval if the interval treap contains one. Since eachiteration of thewhileloop takesO(1)time and the expected height of ann-node treap isO(logn),intervalSearchtakes expectedO(logn)time.2Note that it may also be an interval in the right subtree that overlapsi.2
350Chapter 14  Augmenting Data Structures0510152025300568151617192526 26302019212391083(a)[0,3]3[6,10]10[5,8]10[8,9]23[15,23]23[16,21]30[17,19]20[26,26]26[19,20]20(b)[25,30]30intmaxFigure 14.4An interval tree.(a)Asetof10intervals,shownsortedbottomtotopbyleftendpoint.(b)The interval tree that represents them. Each nodexcontains an interval, shown above the dashedline, and the maximum value of any interval endpoint in the subtree rooted atx,shownbelowthedashed line. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.x:maxDmax.x:int:high;x:left:max;x:right:max/:Thus, by Theorem 14.1, insertion and deletion run inO.lgn/time. In fact, wecan update themaxattributes after a rotation inO.1/time, as Exercises 14.2-3and 14.3-1 show.Step 4: Developing new operationsThe only new operation we need is INTERVAL-SEARCH.T; i/,whichfindsanodein treeTwhose interval overlaps intervali.Ifthereisnointervalthatoverlapsiinthe tree, the procedure returns a pointer to the sentinelT:nil.(a)[16,21] 30 8[17,19] 20 13[19,20] 20 17[25,30] 30 10[26,26] 26 11[15,23] 23 16[8,9] 23 12[6,10] 10 20[5,8] 10 17[0,3] 3 21interv imax priority𝙽𝚘𝚍𝚎(b)Figure 2.An interval treap. (a) A set of 10 intervals, shown sorted bottom to topby left endpoint. (Source: CLRS.) (b) The interval treap that represents them. Eachnodexcontains, from top to bottom, an interval, the maximum value of any intervalendpoint in the subtree rooted atx, and a priority field. An inorder tree walk of thetree lists the nodes in sorted order by left endpoint.Example 1: Successful search.Suppose we wish to find an interval that overlaps the intervali=[22,25]in the interval treap of Figure 2. We begin withxas the root, which contains[16,21]and does not overlapi. Sincex.left.imax=23is greater thani.low=22, the loop continueswithxas the left child of the root — the node containing[8,9], which also does not overlapi. Thistime,x.left.imax=10is less thani.low=22, and so the loop continues with the right child ofxas the newx. Because the interval[15,23]stored in this node overlapsi, the procedure returns thisnode.Example 2: Unsuccessful search.Suppose we wish to find an interval that overlapsi=[11,14]in the interval treap of Figure 2. We once again begin withxas the root. Since the root’s interval[16,21]does not overlapi, and sincex.left.imax=23is greater thani.low=11, we go left tothe node containing[8,9]. Interval[8,9]does not overlapi, andx.left.imax=10is less thani.low=11, and so we go right. (Note that no interval in the left subtree overlapsi.) Interval[15,23]does not overlapi, and its left child isnull, so again we go right, the loop terminates, andwe returnnull.3350Chapter 14  Augmenting Data Structures0510152025300568151617192526 26302019212391083(a)[0,3]3[6,10]10[5,8]10[8,9]23[15,23]23[16,21]30[17,19]20[26,26]26[19,20]20(b)[25,30]30intmaxFigure 14.4An interval tree.(a)Asetof10intervals,shownsortedbottomtotopbyleftendpoint.(b)The interval tree that represents them. Each nodexcontains an interval, shown above the dashedline, and the maximum value of any interval endpoint in the subtree rooted atx,shownbelowthedashed line. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.x:maxDmax.x:int:high;x:left:max;x:right:max/:Thus, by Theorem 14.1, insertion and deletion run inO.lgn/time. In fact, wecan update themaxattributes after a rotation inO.1/time, as Exercises 14.2-3and 14.3-1 show.Step 4: Developing new operationsThe only new operation we need is INTERVAL-SEARCH.T; i/,whichfindsanodein treeTwhose interval overlaps intervali.Ifthereisnointervalthatoverlapsiinthe tree, the procedure returns a pointer to the sentinelT:nil.(a)[16,21] 30 8[17,19] 20 13[19,20] 20 17[25,30] 30 10[26,26] 26 11[15,23] 23 16[8,9] 23 12[6,10] 10 20[5,8] 10 17[0,3] 3 21interv imax priority𝙽𝚘𝚍𝚎(b)Figure 2.An interval treap. (a) A set of 10 intervals, shown sorted bottom to topby left endpoint. (Source: CLRS.) (b) The interval treap that represents them. Eachnodexcontains, from top to bottom, an interval, the maximum value of any intervalendpoint in the subtree rooted atx, and a priority field. An inorder tree walk of thetree lists the nodes in sorted order by left endpoint.Example 1: Successful search.Suppose we wish to find an interval that overlaps the intervali=[22,25]in the interval treap of Figure 2. We begin withxas the root, which contains[16,21]and does not overlapi. Sincex.left.imax=23is greater thani.low=22, the loop continueswithxas the left child of the root — the node containing[8,9], which also does not overlapi. Thistime,x.left.imax=10is less thani.low=22, and so the loop continues with the right child ofxas the newx. Because the interval[15,23]stored in this node overlapsi, the procedure returns thisnode.Example 2: Unsuccessful search.Suppose we wish to find an interval that overlapsi=[11,14]in the interval treap of Figure 2. We once again begin withxas the root. Since the root’s interval[16,21]does not overlapi, and sincex.left.imax=23is greater thani.low=11, we go left tothe node containing[8,9]. Interval[8,9]does not overlapi, andx.left.imax=10is less thani.low=11, and so we go right. (Note that no interval in the left subtree overlapsi.) Interval[15,23]does not overlapi, and its left child isnull, so again we go right, the loop terminates, andwe returnnull.3
3. Updating the Interval TreapYou must implement interval insertion and interval deletion on an interval treap so that theseoperations run in expectedO(logn)time, wherenis the number of intervals. This time boundincludes the work in updating all necessary data fields in the interval treap. Insertions and deletionson an interval treap are performed by modifying the corresponding operations for an ordinary treap.We outline these modifications next — you must supply the additional details.3.1.Insertion.As seen in class, inserting a nodezinto an ordinary treap is done in two phases.The first phase assigns a random priority tozand then goes down the tree from the root, followinga path determined byz.key, insertingzas a child of an existing node. The second phase goes upthe tree, performing rotations to satisfy the constraint thatv.priority>v.parent.priorityforevery nodevin the treap, except the root.Now suppose we want to insert a nodez, wherez.intervreferences an interval andz.priorityhas been assigned a random integer, into an interval treap.  We begin by makingz.imax=z.interv.high. We then proceed to the first phase, which is conducted as in an ordinary treap, ex-cept that we now usez.interv.lowas the key ofz, and we makex.imax=max(x.imax,z.interv.high)for each nodexon the simple path traversed from the root down toward the leaves. Since the ex-pected number of nodes on the traversed path isO(logn), the additional cost of maintaining theimaxfields isO(logn).In the second phase, the only structural changes to the treap are caused by rotations, whichdepend only on the node priorities. A rotation is a local operation: only two nodes have theirimaxfields invalidated. We can update these fields inO(1)time per rotation using the fact that thevalue ofx.imaxfor any nodexcan be determined fromx.intervand theimaxvalues of nodex’schildren as follows.x.imax=x.interv.highifxis a leafmax{x.interv.high,x.left.imax}ifx.right==nullmax{x.interv.high,x.right.imax}ifx.left==nullmax{x.interv.high,x.left.imax,x.right.imax}otherwise.The expected number of rotations is bounded by the expected height of the treap, which isO(logn).Thus, the expected time to perform an insertion, including maintaining theimaxfields, isO(logn).Figure 3 shows an example of interval insertion.3.2.Deletion.Deleting of a nodezfrom an ordinary treap is also done in two phases. The firstphase is exactly like deletion in an ordinary binary search tree, and has three cases3:(1)zhas no left child:Then, replacezby its right child, which may benull.(2)zhas a left child, but no right child:Then, replacezby its left child.(3)zhas two children:Then, replacezby its successory=Minimum(z.right).The second phase rotatesz’s replacementy(assumingyis not null) down the tree as far as necessaryto satisfy the constraint thatv.priority>v.parent.priorityfor every nodev.Now, suppose we want to delete a nodezfrom an interval treap. We begin by deletingzas inthe first phase of ordinary treap deletion. Next, we update the necessaryimaxfields by traversinga path up the treap.3Refer to CLRS, Chapter 12, and pages 15–22 of the slides on binary search trees.4
[16,21] 30 8[17,19] 20 13[19,20] 20 17[25,30] 30 10[26,26] 26 11[15,23] 23 16[8,9] 25 12[6,10] 25 20[5,8] 25 17[0,3] 3 21[7,25] 25 9z(a)[16,21] 30 8[17,19] 20 13[19,20] 20 17[25,30] 30 10[26,26] 26 11[15,23] 23 16[8,9] 25 12[7,25] 25 9[5,8] 25 17[0,3] 3 21[6,10] 10 20z(b)[16,21] 30 8[17,19] 20 13[19,20] 20 17[25,30] 30 10[26,26] 26 11[15,23] 23 16[8,9] 25 12[7,25] 25 9[5,8] 10 17[6,10] 10 20[0,3] 3 21z(c)[16,21] 30 8[17,19] 20 13[19,20] 20 17[25,30] 30 10[26,26] 26 11[7,25] 25 9[5,8] 10 17[6,10] 10 20[0,3] 3 21[15,23] 23 16[8,9] 23 12z(d)Figure 3.Inserting nodez, withz.interv=[7,25], into the interval treap ofFigure 1(b). (a) The interval treap after phase 1. The nodes traversed are shaded,and the modifiedimaxvalues are shown in boldface. Nodezis assigned a priorityof 9, which is lower than the priority ofz’s parent.  (b) After the first rotation,z.priority<z.parent.priority. (c) After the second rotation, we still havez.priority<z.parent.priority. (d) After the third rotation, all the priorityconstraints are satisfied. Notice howimaxfields are updated after each rotation.•Ifzhas been replaced bynull, the path goes from the former parent ofzto the root of thetreap.•Ifzhas been replaced by a nodey, the path starts aty’s original position in the treap andgoes up to the root.In both cases, we decrement theimaxfield of each node on the path, as needed. Since theexpected length of this path isO(logn)in ann-node treap, the time spent in traversing the path toupdateimaxfields isO(logn).Finally, ifzhas been replaced by a nodey, we rotateydownward as in an ordinary treap, inorder to reestablish the correct priority relationships. We handle the rotations in the same manneras for insertion — that is, we updateimaxfields after each rotation. Thus, like insertion, deletiontakes expectedO(logn)time for ann-node interval treap.5
Note.We strongly encourage you to draw several examples of deletion from aninterval treap, in order to understand the work involved. Once you have developedan intuition for the process, you can develop the pseudocode for deletion.4. RequirementsHere we list the Java classes and methods that your program must support. You may, of course,implement other auxiliary classes and methods, as needed.4.1.Interval.TheIntervalclass represents intervals.  To avoid problems with numericalprecision, the endpoints of intervals will be integers. The class must provide the following methods,all of which must run in constant time.•Interval(int low, int high): Constructor with two parameters: thelowandhighendpoints.•int getLow(): Returns the low endpoint of the interval.•int getHigh(): Returns the high endpoint of the interval.4.2.Node.TheNodeclass represents the nodes of the treap. The following methods must beprovided, all of which must run in constant time.•Node (Interval i): Constructor that takes anIntervalobjectias its parameter. Theconstructor must generate a priority for the node. Therefore, after creation of aNodeobject,getPriority()(defined below) must return the priority of this node.•Node getParent(): Returns the parent of this node.•Node getLeft(): Returns the left child of this node.•Node getRight(): Returns the right child of this node.•Interval getInterv(): Returns the interval object stored in this node.•int getIMax(): Returns the value of theimaxfield of this node.•int getPriority(): Returns the priority of this node.4.3.IntervalTreap.TheIntervalTreapclass represents an interval treap.  The followingmethods must be provided, the first four of which should run in constant time.•IntervalTreap(): Constructor with no parameters.•Node getRoot(): Returns a reference to the root node.•int getSize(): Returns the number of nodes in the treap.•int getHeight(): Returns the height of the treap.•void intervalInsert(Node z): adds nodez, whoseintervattribute references anIntervalobject, to the interval treap. This operation must maintain the required intervaltreap properties. The expected running time of this method should beO(logn)on ann-nodeinterval treap.•void intervalDelete(Node z): removes nodezfrom the interval treap. This operationmust maintain the required interval treap properties. The expected running time of thismethod should beO(logn)on ann-node interval treap.•Node intervalSearch(Interval i): returns a reference to a nodexin the intervaltreap such thatx.intervoverlaps intervali, ornullif no such element is in the treap.This method must not modify the interval treap. The expected running time of this methodshould beO(logn)on ann-node interval treap.6
5. Extra CreditFor extra credit, add the following two methods toIntervalTreap.•Node intervalSearchExactly(Interval i): Returns a reference to aNodeobjectxin the treap such thatx.interv.low=i.lowandx.interv.high=i.high, ornullifno such node exists. The expected running time of this method should beO(logn)on ann-node interval treap.(5 extra credit points)•List<Interval> overlappingIntervals(Interval i): returns a list all intervals inthe treap that overlapi. This method must not modify the interval treap. The expectedrunning time of this method should beO(min(n,klogn)), wherekis the number of intervalsin the output list.(10 extra credit points)6. Guidelines on Code Submission•Use the Java default package (unnamed package). While this is not good coding practicefor larger applications, it is more convenient for testing.•Make all the methods and constructors explicitly public.•You may design helper classes and methods in addition to those listed in Sections 4and 5.  However, every class and method listed in that section must be implementedexactly as specified. This includes–the names of methods and classes (remember that Java is case-sensitive),–the return types of the methods, and–the types and order of parameters of each method/constructor.If you fail to follow these requirements, you will lose a significant portion of the points,even if your program is correct.•You are not allowed to have external JARs as dependencies. You may use built-in packagessuch asjava.util.List.•Please include all team members names as a JavaDoc comment in each of the Java files.•Create the project folder as follows:<directory-name>/src/*.java. This folder shouldncludeonly.javafiles. Do not include any.classor other files.•Create a zip file of your project folder.•Upload your zip file on Canvas. Only one submission per team.Your grade will depend on adherence to specifications, correctness, and efficiency.Programs that do not compile will receive zero credit.Important NoteSome aspects of this specification are subject to change in response to issues detected by studentsor the course staff.Check Canvas and Piazza regularly for updates and clarifications.7
